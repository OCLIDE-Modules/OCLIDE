return "local component_invoke = component.invoke\nfunction boot_invoke(address, method, ...)\n  local result = table.pack(pcall(component_invoke, address, method, ...))\n  if not result[1] then\n    return nil, result[2]\n  else\n    return table.unpack(result, 2, result.n)\n  end\nend\n\n-- backwards compatibility, may remove later\nlocal eeprom = component.list(\"eeprom\")()\ncomputer.getBootAddress = function()\n  return boot_invoke(eeprom, \"getData\")\nend\ncomputer.setBootAddress = function(address)\n  return boot_invoke(eeprom, \"setData\", address)\nend\n\ndo\n  local screen = component.list(\"screen\")()\n  local gpu = component.list(\"gpu\")()\n  if gpu and screen then\n    boot_invoke(gpu, \"bind\", screen)\n  end\nend\nlocal function tryLoadFrom(address)\n  local handle, reason = boot_invoke(address, \"open\", \"/init.lua\")\n  if not handle then\n    return nil, reason\n  end\n  local buffer = \"\"\n  repeat\n    local data, reason = boot_invoke(address, \"read\", handle, math.huge)\n    if not data and reason then\n      return nil, reason\n    end\n    buffer = buffer .. (data or \"\")\n  until not data\n  boot_invoke(address, \"close\", handle)\n  return load(buffer, \"=init\")\nend\nlocal init, reason\nif computer.getBootAddress() then\n  init, reason = tryLoadFrom(computer.getBootAddress())\nend\nif not init then\n  computer.setBootAddress()\n  for address in component.list(\"filesystem\") do\n    init, reason = tryLoadFrom(address)\n    if init then\n      computer.setBootAddress(address)\n      break\n    end\n  end\nend\nif not init then\n  error(\"no bootable medium found\" .. (reason and (\": \" .. tostring(reason)) or \"\"), 0)\nend\ncomputer.beep(1000, 0.2)\ninit()","8cd40387-d6a2-4a55-8b29-dcbc07559a8b","EEPROM",false